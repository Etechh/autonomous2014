#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyro,           sensorAnalogInactive)
#pragma config(Sensor, S3,     IR,             sensorI2CCustom)
#pragma config(Sensor, S4,     HTAC,                sensorI2CCustom)
#pragma config(Motor,  motorA,          flag,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          jaw,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          nonee,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     fr,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     br,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     noone,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     none,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     bl,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     fl,            tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    armr,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    arml,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

//Make sure these drivers and "common.h" are present in *\Robomatter Inc\ROBOTC Development Environment\Includes
#include "hitechnic-gyro.h"
#include "hitechnic-irseeker-v2.h"
#include "hitechnic-accelerometer-float.h"

float xcal,ycal,zcal;

float xacc = 0;
float yacc = 0;
float zacc = 0;

float sum_error_kalman = 0;
float sum_error_measure = 0;

float frand() {
	return 2*((rand()/32767.0) - 0.5);
}

task accelerometer()
{

	//Kalman filter initialization
	//initial values for the kalman filter
	float x_est_last = 0;
	float P_last = 0;
	//the noise in the system
	float Q = 0.022;
	float R = 0.617;

	float K;
	float P;
	float P_temp;
	float x_temp_est;
	float x_est;
	float z_measured; //the 'noisy' value we measured
	float z_real = 0; //the ideal value we wish to measure

	srand(0);

	//Measuring
	HTACreadAllAxes(HTAC, xacc, yacc, zacc);
	xacc -= xcal;
	yacc -= ycal;
	zacc -= zcal;

	//initialize with a measurement
	x_est_last = xacc;

	writeDebugStreamLine("t,measurement,kalman");

	time1[T1] = 0;

	while(true)
	{
		//do a prediction
		x_temp_est = x_est_last;
		P_temp = P_last + Q;
		//calculate the Kalman gain
		K = P_temp * (1.0/(P_temp + R));
		//measure
		HTACreadAllAxes(HTAC, xacc, yacc, zacc);
		xacc -= xcal;
		yacc -= ycal;
		zacc -= zcal;
		z_measured = xacc; //the real measurement plus noise
		//correct
		x_est = x_temp_est + K * (z_measured - x_temp_est);
		P = (1- K) * P_temp;
		//we have our new system

		//writeDebugStreamLine("Ideal: %6.3f \n",z_real);
		//writeDebugStreamLine("Measured: %6.3f [diff:%.3f]\n",z_measured,abs(z_real-z_measured));
		//writeDebugStreamLine("Kalman: %6.3f [diff:%.3f]\n",x_est,abs(z_real - x_est));
		writeDebugStreamLine("%d,%d,%d",time1[T1],z_measured,x_est);

		sum_error_kalman += abs(z_real - x_est);
		sum_error_measure += abs(z_real-z_measured);

		//update our last's
		P_last = P;
		x_est_last = x_est;
	}

	//writeDebugStreamLine("%d,%d,%d,%d,%d",time1[T1],xacc,yacc,zacc);

}

task main()
{
	HTACreadAllAxes(HTAC, xcal, ycal, zcal);


	motor[fl] = -30;
	motor[fr] = 30;
	motor[bl] = -30;
	motor[br] = 30;

	wait1Msec(500);
	time1[T1] = 0;
	StartTask(accelerometer); //Starting when a should be 0

	wait1Msec(1000);

	StopTask(accelerometer);

	motor[fl] = 0;
	motor[fr] = 0;
	motor[bl] = 0;
	motor[br] = 0;

	writeDebugStreamLine("Tot err raw measured:  %f\n",sum_error_measure);
	writeDebugStreamLine("Tot err kalman: %f\n",sum_error_kalman);
	writeDebugStreamLine("Reduction: %d%% \n",100-(int)((sum_error_kalman/sum_error_measure)*100));
}
