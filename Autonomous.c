#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyro,           sensorAnalogInactive)
#pragma config(Sensor, S3,     IR,             sensorI2CCustom)
#pragma config(Motor,  motorA,          flag,          tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          jawsr,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          jawsl,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     fr,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     br,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     bl,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     fl,            tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    arml,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    armr,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* LEGO robot
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyro,           sensorAnalogInactive)
#pragma config(Motor,  motorA,          right,         tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          left,          tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          testmount,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     fl,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     bl,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     fr,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     br,            tmotorTetrix, openLoop)
*/

#include "JoystickDriver.c"

//Make sure these drivers and "common.h" are present in *\Robomatter Inc\ROBOTC Development Environment\Includes
#include "hitechnic-gyro.h"
#include "hitechnic-irseeker-v2.h"


//Constants
float TURNSPD = 20;
float MOVESPD = 30;

float REFRESHGYRO = 100; //in ms

float ARMUP45 = 64; //? Values for right servo
float ARMCARRY = 210; //?
float ARMDOWN = 230; //?


//Starting coordinates (default x,y,r = 0,0,0)
float xcur = 0;
float ycur = 0;
float rcur = 0;


int servogoal = 0;


void initializeRobot()
{
	HTGYROstartCal(gyro); //Calibrate gyro sensor, make sure robot is still

	servo[arml] = 230; //Set servo

	return;
}



void turn(float direction)
{
	motor[fl] = direction * TURNSPD;
	motor[fr] = direction * TURNSPD;
	motor[bl] = direction * TURNSPD;
	motor[br] = direction * TURNSPD;
}



void still()
{
	motor[fl] = 0;
	motor[fr] = 0;
	motor[bl] = 0;
	motor[br] = 0;
}



void move(float direction, int time) //Currently works only for direction = 0
{
	motor[fl] = MOVESPD;
	motor[fr] = MOVESPD;
	motor[bl] = MOVESPD;
	motor[br] = MOVESPD;

	wait1Msec(time);

	motor[fl] = 0;
	motor[fr] = 0;
	motor[bl] = 0;
	motor[br] = 0;
}



//Function for turning, use: turnto(0 to 359 degrees, relative to 0 position)
void turnto(float rgoal)
{
	float rotspd = 0;
	float direction;
	float turnval;
	float turncur = 0;

	//Check which way should be turned and adjust motor direction
	if (rgoal >= 360)
		rgoal = rgoal - 360;

	if (rgoal == rcur)
	{
		direction = 0;
		turnval = 0;
	}
	else if (rgoal > rcur && rgoal - rcur <= 180)
	{
		direction = 1;
		turnval = rgoal - rcur;
	}
	else if (rgoal < rcur && rcur - rgoal > 180)
	{
		direction = 1;
		turnval = 360 - rcur + rgoal;
	}
	else
	{
		direction = -1;
		turnval = rcur - rgoal;
	}

	//Turn on motors
	turn(direction);

	while (abs(turncur) < abs(turnval))
	{
		time1[T1] = 0; //Reset timer

		while(time1[T1] < REFRESHGYRO)
			wait1Msec(1);

		time1[T1] = 0; //Reset timer

		//Get rotationspeed value from gyrosensor
		rotspd = HTGYROreadRot(gyro);

		//Jawohl, ein Riemannsumm fur die integrale!
		turncur += rotspd * (REFRESHGYRO/1000);

		//Display heading on the display for testing
		nxtDisplayCenteredBigTextLine(3, "%2.0f", rcur + turncur);
	}

	rcur = turncur + rcur;

	still();
}



void slitherto(float xgoal, float ygoal, float rgoal)
{
	float dy;
	float dx;

	dy = ygoal - ycur;
	dx = xgoal - xcur;
}



void pickup() //Untested
{
	servo[armr] = ARMDOWN;
	servo[arml] = ARMDOWN;
	motor[jawsr] = 100;

	nxtDisplayCenteredBigTextLine(3, "%2.0f", ServoValue[armr]);
	wait1Msec(1000); //Let servos move
	nxtDisplayCenteredBigTextLine(3, "%2.0f", ServoValue[armr]);

	//move(0,1000); //Barge into blocks and hope to pick some up

	servo[armr] = ARMCARRY;
	servo[arml] = ARMCARRY;
	motor[jawsr] = 50; //Saving energy while carrying

	nxtDisplayCenteredBigTextLine(3, "%2.0f", ServoValue[armr]);
	wait1Msec(1000); //Let servos move
	nxtDisplayCenteredBigTextLine(3, "%2.0f", ServoValue[armr]);
}



void dispose(float height) //Height in cm - 45 cm, untested, currently only 45cm
{
	servo[armr] = ARMUP45;
	servo[arml] = ARMUP45;
	nxtDisplayCenteredBigTextLine(3, "%2.0f", ServoValue[armr]);
	wait1Msec(1000);
	nxtDisplayCenteredBigTextLine(3, "%2.0f", ServoValue[armr]);

	//move(0,300); //Highly depends on distance to crate when starting function

	motor[jawsr] = -100; //Throw it all out

	nxtDisplayCenteredBigTextLine(3, "%2.0f", ServoValue[armr]);
	wait1Msec(1000);
	nxtDisplayCenteredBigTextLine(3, "%2.0f", ServoValue[armr]);

	motor[jawsr] = 0;
}



task main()
{
	initializeRobot();//Calibrate sensors

	//waitForStart(); //Wait for the beginning of autonomous phase

	wait1Msec(1000); //Stand still to make sure calibration is finished

	//Testing: it should lower arm, pick up blocks, raise arm and dispose of blocks
	//pickup();
	//PlaySound(soundBlip);
	//dispose(0);

	//Testing servovalues
	while(servogoal < 260)
	{
		servo[arml] = servogoal;
		wait1Msec(1000);
		PlaySound(soundBlip);
		servogoal = servogoal + 10;
		while(nNxtButtonPressed != 2)
		{
			nxtDisplayCenteredBigTextLine(3, "%2.0f", ServoValue[arml]);
		}
	}


}
