#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyro,           sensorAnalogInactive)
#pragma config(Sensor, S3,     IR,             sensorI2CCustom)
#pragma config(Motor,  motorA,          flag,          tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          jawsr,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          jawsl,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     fr,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     br,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     bl,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     fl,            tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    arml,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    armr,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* LEGO robot
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyro,           sensorAnalogInactive)
#pragma config(Motor,  motorA,          right,         tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          left,          tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          testmount,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     fl,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     bl,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     fr,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     br,            tmotorTetrix, openLoop)
*/

#include "JoystickDriver.c"

//Make sure these drivers and "common.h" are present in *\Robomatter Inc\ROBOTC Development Environment\Includes
#include "hitechnic-gyro.h"
#include "hitechnic-irseeker-v2.h"

float TURNSPD = 20;
float REFRESHGYRO = 100; //in ms

//Starting coordinates (default x,y,r = 0,0,0)
float xcur = 0;
float ycur = 0;
float rcur = 0;

void initializeRobot()
{
	HTGYROstartCal(gyro); //Calibrate gyro sensor, make sure robot is still

	return;
}


/*LEGO robot
void turn(float direction)
{
	//motor[right] = -1 * direction * TURNSPD;
	//motor[left] = direction * TURNSPD;
	motor[testmount] = direction * 30;
}

void still()
{
	//motor[right] = 0;
	//motor[left] = 0;
	motor[testmount] = 0;
}
*/


// Tetrix robot
void turn(float direction)
{
	motor[fl] = direction * TURNSPD;
	motor[fr] = direction * TURNSPD;
	motor[bl] = direction * TURNSPD;
	motor[br] = direction * TURNSPD;
}

void still()
{
	motor[fl] = 0;
	motor[fr] = 0;
	motor[bl] = 0;
	motor[br] = 0;
}



//Function for turning, use: turnto(0 to 359 degrees, relative to 0 position)
void turnto(float rgoal)
{
	float rotspd = 0;
	float direction;
	float turnval;
	float turncur = 0;

	//Check which way should be turned and adjust motor direction
	if (rgoal >= 360)
		rgoal = rgoal - 360;

	if (rgoal == rcur)
	{
		direction = 0;
		turnval = 0;
	}
	else if (rgoal > rcur && rgoal - rcur <= 180)
	{
		direction = 1;
		turnval = rgoal - rcur;
	}
	else if (rgoal < rcur && rcur - rgoal > 180)
	{
		direction = 1;
		turnval = 360 - rcur + rgoal;
	}
	else
	{
		direction = -1;
		turnval = rcur - rgoal;
	}

	//Turn on motors
	turn(direction);

	while (abs(turncur) < abs(turnval))
	{
		time1[T1] = 0; //Reset timer

		while(time1[T1] < REFRESHGYRO)
			wait1Msec(1);

		time1[T1] = 0; //Reset timer

		//Get rotationspeed value from gyrosensor
		rotspd = HTGYROreadRot(gyro);

		//Jawohl, ein Riemannsumm fur die integrale!
		turncur += rotspd * (REFRESHGYRO/1000);

		//Display heading on the display for testing
		nxtDisplayCenteredBigTextLine(3, "%2.0f", rcur + turncur);
	}

	rcur = turncur + rcur;

	still();
}



void slitherto(float xgoal, float ygoal, float rgoal)
{
	float dy;
	float dx;

	dy = ygoal - ycur;
	dx = xgoal - xcur;




}



task main()
{
	initializeRobot();//Calibrate sensors

	//waitForStart(); //Wait for the beginning of autonomous phase

	wait1Msec(2000);

	turnto(180);
	PlaySound(soundBlip);
	turnto(1);
	PlaySound(soundBlip);
}
