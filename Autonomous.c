#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyro,           sensorAnalogInactive)
#pragma config(Sensor, S3,     IR,             sensorI2CCustom)
#pragma config(Sensor, S4,     HTAC,                sensorI2CCustom)
#pragma config(Motor,  motorA,          flag,          tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          jawsr,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          jawsl,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     fr,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     br,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     bl,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     fl,            tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    armr,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    arml,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* LEGO robot
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyro,           sensorAnalogInactive)
#pragma config(Motor,  motorA,          right,         tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          left,          tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          testmount,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     fl,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     bl,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     fr,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     br,            tmotorTetrix, openLoop)
*/

#include "JoystickDriver.c"

//Make sure these drivers and "common.h" are present in *\Robomatter Inc\ROBOTC Development Environment\Includes
#include "hitechnic-gyro.h"
#include "hitechnic-irseeker-v2.h"
#include "hitechnic-accelerometer-float.h"


//Constants
float TURNSPD = 20;
float MOVESPD = 30;

float REFRESH = 1; //in ms

int ARMUPL45 = 180;
int ARMUPR45 = 40;
int ARMCARRYL = 60;
int ARMCARRYR = 170;
int ARMDOWNL = 40;
int ARMDOWNR = 190;
int POSPERCM = 10;


//Starting coordinates (default x,y,r = 0,0,0)
float xcur = 0;
float ycur = 0;
float rcur = 0;

float vx = 0;
float vy = 0;

float xcal[1000], ycal[1000], zcal[1000];
float xcald,ycald,zcald;
float xacc, yacc;

float xaxle,yaxle,zaxle;

float alfa,beta;
float tanalfa;
float atot;

float g = 981; //cm/s^2

int servogoal = 0;


void calibrateacc(int times)
{
	float xcaltot,ycaltot,zcaltot;

	for(int i = 0; i < times; i++)
	{
		HTACreadAllAxes(HTAC, xcal[i], ycal[i], zcal[i]);
  	wait1Msec(1);
  }

  for(int i = 0; i < times; i++)
	{
		xcaltot += xcal[i];
		ycaltot += ycal[i];
		zcaltot += zcal[i];
  }

  xcald = xcaltot/times;
  ycald = ycaltot/times;
  zcald = zcaltot/times;
}

void initializeRobot()
{
	HTGYROstartCal(gyro); //Calibrate gyro sensor, make sure robot is still
	calibrateacc(1000);

	return;
}



void turn(float direction)
{
	motor[fl] = direction * TURNSPD;
	motor[fr] = direction * TURNSPD;
	motor[bl] = direction * TURNSPD;
	motor[br] = direction * TURNSPD;
}



void still()
{
	motor[fl] = 0;
	motor[fr] = 0;
	motor[bl] = 0;
	motor[br] = 0;
}



void move(float direction, int time) //Currently works only for direction = 0
{
	motor[fl] = MOVESPD;
	motor[fr] = MOVESPD;
	motor[bl] = MOVESPD;
	motor[br] = MOVESPD;

	wait1Msec(time);

	motor[fl] = 0;
	motor[fr] = 0;
	motor[bl] = 0;
	motor[br] = 0;
}



//Function for turning, use: turnto(0 to 359 degrees, relative to 0 position)
void turnto(float rgoal)
{
	float rotspd = 0;
	float direction;
	float turnval;
	float turncur = 0;

	//Check which way should be turned and adjust motor direction
	if (rgoal >= 360)
		rgoal = rgoal - 360;

	if (rgoal == rcur)
	{
		direction = 0;
		turnval = 0;
	}
	else if (rgoal > rcur && rgoal - rcur <= 180)
	{
		direction = 1;
		turnval = rgoal - rcur;
	}
	else if (rgoal < rcur && rcur - rgoal > 180)
	{
		direction = 1;
		turnval = 360 - rcur + rgoal;
	}
	else
	{
		direction = -1;
		turnval = rcur - rgoal;
	}

	//Turn on motors
	turn(direction);

	while (abs(turncur) < abs(turnval))
	{
		time1[T1] = 0; //Reset timer

		while(time1[T1] < REFRESH)
			wait1Msec(1);

		time1[T1] = 0; //Reset timer

		//Get rotationspeed value from gyrosensor
		rotspd = HTGYROreadRot(gyro);

		//Jawohl, ein Riemannsumm fur die integrale!
		turncur += rotspd * (REFRESH/1000);

		//Display heading on the display for testing
		nxtDisplayCenteredBigTextLine(3, "%2.0f", rcur + turncur);
	}

	rcur = turncur + rcur;

	still();
}



void shiftto(float xgoal, float ygoal, float rgoal)
{
	float dy;
	float dx;


	dy = ygoal - ycur;
	dx = xgoal - xcur;


}



void pickup() //Untested
{
	servo[armr] = ARMDOWNR;
	servo[arml] = ARMDOWNL;
	motor[jawsr] = 100;

	wait1Msec(1000); //Let servos move

	//move(0,1000); //Barge into blocks and hope to pick some up

	servo[armr] = ARMCARRYR;
	servo[arml] = ARMCARRYL;
	motor[jawsr] = 50; //Saving energy while carrying

	wait1Msec(1000); //Let servos move
}



void dispose(float height) //Height in cm - 45 cm, untested
{
	servo[armr] = ARMUPR45 - POSPERCM * height;
	servo[arml] = ARMUPL45 + POSPERCM * height;
	wait1Msec(1000);

	//move(0,300); //Highly depends on distance to crate when starting function

	motor[jawsr] = -100; //Throw it all out

	wait1Msec(1000);

	motor[jawsr] = 0;
}

float tan(float angle)
{
	float tangent;

	tangent = sin(angle)/cos(angle);

	return tangent;
}

/*void checkacc() //Wat
{
	 //203 units = 981 cm/s^2

	HTACreadAllAxes(HTAC, xaxle, yaxle, zaxle);

	xaxle = (xaxle/203) * 981; //Converting measurements from unit to cm/s^2
	yaxle = (yaxle/203) * 981;
	zaxle = (zaxle/203) * 981;

	alfa = atan(zaxle/xaxle);
	atot = xaxle/cos(alfa);
	beta = asin(g/atot);
	xacc = g/tan(beta);

	//alfa = atan(zaxle/yaxle);
	//atot = yaxle/cos(alfa);
	//beta = asin(g/atot);
	//yacc = g/tan(beta);

	xcur += vx * REFRESH + .5 * xacc * REFRESH * REFRESH;
	vx += xacc * REFRESH;

	ycur += vy * REFRESH + .5 * yacc * REFRESH * REFRESH;
	vy += yacc * REFRESH;
}*/

void checkacc() //The simple and probably wildy inaccurate version
{
	HTACreadAllAxes(HTAC, xaxle, yaxle, zaxle);

	xaxle -= xcald; //Correcting for tilt
	yaxle -= ycald;
	zaxle -= zcald;

	xacc = floor((xaxle/203) * 981); //Converting measurements from unit to cm/s^2
	yacc = floor((yaxle/203) * 981);

	xcur += vx * REFRESH + .5 * xacc * REFRESH * REFRESH;
	vx += xacc * REFRESH;

	ycur += vy * REFRESH + .5 * yacc * REFRESH * REFRESH;
	vy += yacc * REFRESH;
}


task main()
{
	initializeRobot();//Calibrate sensors

	//waitForStart(); //Wait for the beginning of autonomous phase

	wait1Msec(1000); //Stand still to make sure calibration is finished

	while(true)
	{
		wait1Msec(REFRESH);

		checkacc();

		nxtDisplayTextLine(2, "   X    Y");
    nxtDisplayTextLine(3, "%4d %4d", xacc, yacc);
    nxtDisplayTextLine(3, "%4d %4d", xcur, ycur);
	}

}
