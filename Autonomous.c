#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyro,           sensorAnalogInactive)
#pragma config(Sensor, S3,     IR,             sensorI2CCustom)
#pragma config(Motor,  motorA,          flag,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          jawsr,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          jawsl,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     fr,            tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C1_2,     br,            tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C2_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     bl,            tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C4_2,     fl,            tmotorTetrix, PIDControl)
#pragma config(Servo,  srvo_S1_C3_1,    arml,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    armr,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

//Make sure these drivers and "common.h" are present in *\Robomatter Inc\ROBOTC Development Environment\Includes
#include "hitechnic-gyro.h"
#include "hitechnic-irseeker-v2.h"

int turnspd = 30;
float rotspd;
float degheading;

int xcur = 0;
int ycur = 0;
float rcur360;
float rcur300;

void initializeRobot()
{
  HTGYROstartCal(gyro); //Calibrate gyro sensor, make sure robot is still

  return;
}

//Function for turning, use: turnto(heading goal for robot relative to starting position in degrees)
void turnto(float rgoal360)
{
	float rotspd = 0;
	int motorspd = 0;

	//Check which way should be turned and adjust motor direction
	if(rcur360 < rgoal360)
	{motorspd = -turnspd;}
	else if(rcur360 > rgoal360)
	{motorspd = turnspd;}

	//Turn on motors
	motor[fl] = motorspd;
	motor[fr] = motorspd;
	motor[bl] = motorspd;
	motor[br] = motorspd;

	while(rcur360 > rgoal360)
	{
		//This is where the motors actually turn, 1 ms at the time
		wait1Msec(1);

		//Get rotationspeed value from gyrosensor
		rotspd = HTGYROreadRot(gyro);

		//Jawohl, ein Riemannsumm fur die integrale!
		rcur300 += rotspd * 0.001;

		rcur360 = (rcur300*360)/300;

		//Display heading on the display for testing
		nxtDisplayCenteredBigTextLine(3, "%2.0f", rcur360);
	}

	//Turn off motors when the while loop ends, so when the heading = the heading goal
	motor[fl] = 0;
	motor[fr] = 0;
	motor[bl] = 0;
	motor[br] = 0;
}

task main()
{
  initializeRobot();//Calibrate sensors

  waitForStart(); //Wait for the beginning of autonomous phase

  wait1Msec(1000);

  turnto(-360);
}
